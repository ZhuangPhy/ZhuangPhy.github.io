<!DOCTYPE html>
<html lang="en">





<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="JPZhuang">
  <meta name="keywords" content="">
  <title>基于对称性的物理(1/2)Lie群 - JPZ</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Physics</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://jptanjing.oss-cn-beijing.aliyuncs.com/blog_QuantumAI/Lie.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2017-10-30 14:23">
      October 30, 2017 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      149
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h3 id="二维旋转">二维旋转</h3>
<p>同一个群（对应一种变换）可以作用于不同类对象：圆（几何图形），或者向量。</p>
<h4 id="矩阵表示变换">矩阵表示变换</h4>
<p>本节考虑向量，可以用旋转矩阵表示向量的旋转或反射</p>
<ul>
<li>旋转</li>
</ul>
<p>将起点位于原点的向量绕原点逆时针旋转 <span class="math inline">\(\theta\)</span> 角度的旋转矩阵为 <span class="math display">\[
R_{\theta}=\left(\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right)
\]</span></p>
<ul>
<li>反射</li>
</ul>
<p>关于 x 轴与 y 轴的反射变换用矩阵表示为: <span class="math display">\[
P_{x}=\left(\begin{array}{cc}
-1 &amp; 0 \\
0 &amp; 1
\end{array}\right) \quad P_{y}=\left(\begin{array}{cc}
1 &amp; 0 \\
0 &amp; -1
\end{array}\right)
\]</span> 将矩阵乘法作为<strong>群乘法</strong> o, 可以验证对于所有的 <span class="math inline">\(\theta\)</span>，<span class="math inline">\(R(\theta)\)</span>，<span class="math inline">\(P_{x}\)</span>，<span class="math inline">\(P_{y}\)</span> 与 矩阵乘法符合群公理，因而构成一个群，亦即旋转与反射变换<strong>构成一个群</strong>。</p>
<h4 id="长度不变的变换">长度不变的变换</h4>
<p>可以用更抽象的方式表达“所有让二维向量长度不变的变换，向量长度就是向量与自身点乘的平方根 <span class="math inline">\((|a|=\sqrt{a \cdot a}) .\)</span> 向量长度在变换 <span class="math inline">\(a \rightarrow a^{\prime}\)</span> 下不变意味着 : <span class="math display">\[
a^{\prime} \cdot a^{\prime} \stackrel{!}{=} a \cdot a
\]</span> 将线性变换对应的矩阵记作 <span class="math inline">\(O\)</span>，变换即为 <span class="math inline">\(a \rightarrow a^{\prime}= O a\)</span> <span class="math display">\[
a \cdot a=a^{T} a \\
\downarrow\\ a^{\prime T} a^{\prime}=( O a)^{T} O a=a^{T} O ^{T} O a \stackrel{!}{=} a^{T} a=a \cdot a
\]</span> 由此可见，使向量长度不变的变换必须满足 <span class="math display">\[
O ^{T} O =I
\]</span> 其中 <span class="math inline">\(I\)</span> 表示单位矩阵。前文的旋转和反射矩阵都满足此条 件</p>
<h5 id="例子">例子</h5>
<p>对于旋转矩阵 <span class="math inline">\(O= R_{\theta}\)</span> <span class="math display">\[
\begin{aligned}
R_{\theta}^{T} R_{\theta}=&amp; \left(\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right)\left(\begin{array}{cc}
\cos \theta &amp; \sin \theta \\
-\sin \theta &amp; \cos \theta
\end{array}\right)\\
=&amp;\left(\begin{array}{cc}
\cos ^{2} \theta+\sin ^{2} \theta &amp; 0 \\
0 &amp; \sin ^{2} \theta+\cos ^{2} \theta
\end{array}\right)\\
=&amp; \left(\begin{array}{ll}
1 &amp; 0 \\
0 &amp; 1
\end{array}\right)
\end{aligned}
\]</span></p>
<h5 id="o-2-群正交群"><span class="math inline">\(O (2)\)</span> 群(正交群)</h5>
<blockquote>
<p><span class="math inline">\(2 \times 2\)</span> 矩阵中所有满足 <span class="math inline">\(O^{T} O=I\)</span> 式的矩阵构成了 <span class="math inline">\(O (2)\)</span> 群，即所有 <span class="math inline">\(2 \times 2\)</span> 正交矩阵构成的群。</p>
</blockquote>
<h5 id="特殊正交群-s-o-2">特殊正交群 <span class="math inline">\(S O (2)\)</span></h5>
<p>我们可以找出这个群中描述旋转变换的那一部分（构成一个子群）。根据 <span class="math display">\[
\begin{aligned}
\operatorname{det}\left( O ^{T} O\right)=&amp; \operatorname{det}\left(O^{T}\right) \operatorname{det}(O) \stackrel{!}{=} \operatorname{det}(I)=1 \\
&amp;(\operatorname{det}( O ))^{2} \stackrel{!}{=} 1 \rightarrow \operatorname{det}( O ) \stackrel{!}{=} \pm 1
\end{aligned}
\]</span> <span class="math inline">\(\operatorname{det} O =1\)</span> 的矩阵对应旋转变换。</p>
<blockquote>
<p>条件 <span class="math display">\[
O ^{T} O =I\\
\operatorname{det} O =1
\]</span> 定义了 <span class="math inline">\(S O (2)\)</span> 群</p>
</blockquote>
<ul>
<li>这里的 <span class="math inline">\(S\)</span> 表示 “特殊' (special)</li>
<li><span class="math inline">\(O\)</span>表示 <span class="math inline">\(^{\prime}\)</span> 正交 '(orthogonal <span class="math inline">\()\)</span></li>
</ul>
<p><span class="math inline">\(S O (2)\)</span> 包含的旋转变换保持了坐标系的取向，即一个<strong>右手坐标系</strong> 经旋转变换后还是右手系，而反射变换会改变它的取向。用线性代数的概念来说，我们规定 <span class="math inline">\(S O (2)\)</span> 中的矩阵行列式必须为+1</p>
<h4 id="用单位复数表示旋转变换">用单位复数表示旋转变换</h4>
<p>还可以用单位复数来表示二维的旋转变换:</p>
<ul>
<li><span class="math inline">\(z=a+i b\)</span></li>
<li><span class="math inline">\(|z|^{2}=z^{*} z=1\)</span></li>
</ul>
<h5 id="u-1-群"><span class="math inline">\(U (1)\)</span> 群</h5>
<blockquote>
<p>所有单位复数构成一个群，称为<span class="math inline">\(U (1)\)</span> 群。</p>
</blockquote>
<p>群乘法即为复数乘法,不难验证它符合群公理。</p>
<p>为了看出它与之前引入的 O(2), SO(2)群的关系，我们将 U(1) 群的条件 一复数的模（长度）为 1 表示为 <span class="math inline">\(\forall U \in U (1)\)</span> <span class="math display">\[
U ^{*} U =1
\]</span> 单位复数另一种写法是： <span class="math display">\[
R_{\theta}= e ^{i \theta}=\cos \theta+i \sin \theta
\]</span> <span class="math inline">\(R_{\theta}\)</span> 的模平方为: <span class="math display">\[
\begin{aligned}
R_{\theta}^{*} R_{\theta}&amp;= e ^{-i \theta} e ^{i \theta}\\
&amp;=(\cos \theta-i \sin \theta)(\cos \theta+i \sin \theta)\\
&amp;=1
\end{aligned}
\]</span></p>
<h5 id="例子-1">例子</h5>
<p>将向量 (3,5) 对应的复数 <span class="math inline">\(z=3+5 i\)</span> 旋转 <span class="math inline">\(90^{\circ}:\)</span> <span class="math display">\[
\begin{aligned}
z \rightarrow z^{\prime}&amp;= e ^{i 90^{\circ}} z\\
&amp;=( \cos 90^{\circ} +i \sin 90^{\circ} )(3+5 i)\\
&amp;=i(3+5 i)\\
&amp;=3 i-5
\end{aligned}
\]</span></p>
<ul>
<li>复数乘以 $ e^{i 90^{}}$ 旋转了<span class="math inline">\(90^{\circ}\)</span>。</li>
<li>需要注意 e <span class="math inline">\(^{i 90^{\circ}}\)</span> 作用于（乘以）向量对应的复数而非向量本身。</li>
<li>描述二维旋转只需要一个参数: 旋转角 <span class="math inline">\(\phi\)</span>. 而复数有两个自由度（实部和虚部），因此我们加上单位复数的限制:<span class="math inline">\(|z|=\)</span> 实部 <span class="math inline">\(^{2}+\)</span> 虚部 <span class="math inline">\(^{2}=1,\)</span> 刚好只剩一个自由度。</li>
</ul>
<h5 id="两种表述的联系">两种表述的联系</h5>
<p>描述二维旋转的两种方式</p>
<ul>
<li>单位复数</li>
<li><span class="math inline">\(2 \times 2\)</span> 矩阵（矩阵元 都是实数）</li>
</ul>
<p>通过如下方式相联系。定义: <span class="math display">\[
1=\left(\begin{array}{ll}
1 &amp; 0 \\
0 &amp; 1
\end{array}\right)
\quad i =\left(\begin{array}{cc}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right)
\]</span> 不难验证这样定义的 1, i 仍然满足: <span class="math display">\[
1^{2}=1, \quad i ^{2}=-1, \quad 1 i = i 1= i
\]</span> 这样单位复数对应的 <span class="math inline">\(2 \times 2\)</span> 实数矩阵为 <span class="math display">\[
\begin{aligned}
R_{\theta}&amp;=\cos \theta+i \sin \theta\\
&amp;=\cos \theta\left(\begin{array}{cc}
1 &amp; 0 \\
0 &amp; 1
\end{array}\right)+\sin \theta\left(\begin{array}{cc}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right)\\
&amp;=\left(\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right)
\end{aligned}
\]</span> 可见，定义了复单位 <span class="math inline">\(i \rightarrow\)</span> 实矩阵 的对应关系后，单位复数就回到了熟悉的旋转矩阵。还有一点要注意：旋转矩阵作用于向量（列矩阵），而我们将 <span class="math inline">\(i\)</span> 与 <span class="math inline">\(2 \times 2\)</span> 的实矩阵相联系，因此被旋转的向量（与个复数对应）也将变成一个 <span class="math inline">\(2 \times 2\)</span> 矩阵。</p>
<h5 id="例子-2">例子</h5>
<p>任意向量 <span class="math inline">\((a, b)\)</span> 对应的复数对应的 <span class="math inline">\(2 \times 2\)</span> 矩阵为: <span class="math display">\[
\begin{aligned}
z&amp;=a+i b\\&amp;=a\left(\begin{array}{cc}
1 &amp; 0 \\
0 &amp; 1
\end{array}\right)+b\left(\begin{array}{cc}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right)\\&amp;=\left(\begin{array}{cc}
a &amp; -b \\
b &amp; a
\end{array}\right)
\end{aligned}
\]</span> 将旋转矩阵作用于 z: <span class="math display">\[
\begin{aligned}
z^{\prime} 
&amp;=R_{\theta} z \\
\left(\begin{array}{cc}
a^{\prime} &amp; -b^{\prime} \\
b^{\prime} &amp; a^{\prime}
\end{array}\right) &amp;=\left(\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right)\left(\begin{array}{cc}
a &amp; -b \\
b &amp; a
\end{array}\right) \\
\left(\begin{array}{ll}
a^{\prime} &amp; -b^{\prime} \\
b^{\prime} &amp; a^{\prime}
\end{array}\right)&amp;=\left(\begin{array}{cc}
a \cos \theta-b \sin \theta &amp; -b \cos \theta-a \sin \theta \\
a \sin \theta+b \cos \theta &amp; -b \sin \theta+a \cos \theta
\end{array}\right)
\end{aligned}
\]</span> 由上式可得 <span class="math display">\[
\begin{array}{l}
a^{\prime}=a \cos \theta-b \sin \theta \\
b^{\prime}=a \sin \theta+b \cos \theta
\end{array}
\]</span> 这与旋转矩阵作用于向量（列矩阵形式）相同： <span class="math display">\[
\left(\begin{array}{cc}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{array}\right)\left(\begin{array}{l}
a \\
b
\end{array}\right)=\left(\begin{array}{c}
a \cos \theta-b \sin \theta \\
a \sin \theta+b \cos \theta
\end{array}\right)=\left(\begin{array}{l}
a^{\prime} \\
b^{\prime}
\end{array}\right)(3.22)
\]</span></p>
<h5 id="同构映射">同构映射</h5>
<p>我们看到这两种表示方法是一回事儿，用数学术语来说，<span class="math inline">\(SO (2)\)</span> 与 <span class="math inline">\(U (1)\)</span> 间有一个<strong>同构映射</strong>。这一点太重要了，之后的篇幅会不断出现这种思想。</p>
<h3 id="三维旋转">三维旋转</h3>
<h4 id="作为基底的矩阵">作为基底的矩阵</h4>
<p>三维向量旋转变换当然可以用 <span class="math inline">\(3 \times 3\)</span> 旋转矩阵 <span class="math display">\[
R_{x}=\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos \theta &amp; -\sin \theta \\
0 &amp; \sin \theta &amp; \cos \theta
\end{array}\right)  
\]</span></p>
<p><span class="math display">\[
R_{y}=\left(\begin{array}{ccc}
\cos \theta &amp; 0 &amp; \sin \theta \\
0 &amp; 1 &amp; 0 \\
-\sin \theta &amp; 0 &amp; \cos \theta
\end{array}\right)
\]</span></p>
<p><span class="math display">\[
R_{z}=\left(\begin{array}{ccc}
\cos \theta &amp; -\sin \theta &amp; 0 \\
\sin \theta &amp; \cos \theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right)
\]</span></p>
<p>类比 <span class="math inline">\(S O (2)\)</span> 群，上面三个矩阵构成了 <span class="math inline">\(S O (3)\)</span> 群的一组<strong>基</strong>。这意味着 <span class="math inline">\(S O (3)\)</span> 中的任意群元（矩阵）都可以写为 <span class="math inline">\(R_{x}, R_{y}, R_{z}\)</span> 的线性组合，且系数唯一。将向量 <span class="math display">\[
\vec{v}=\left(\begin{array}{l}
1 \\
0 \\
0
\end{array}\right)
\]</span> 绕 z 轴旋转就是用旋转矩阵乘以向量： <span class="math display">\[
R_{z}(\theta) \vec{v}=\left(\begin{array}{ccc}
\cos \theta &amp; -\sin \theta &amp; 0 \\
\sin \theta &amp; \cos \theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right)\left(\begin{array}{l}
1 \\
0 \\
0
\end{array}\right)=\left(\begin{array}{c}
\cos \theta \\
\sin \theta \\
0
\end{array}\right)
\]</span></p>
<h4 id="四元数quaternions">四元数（quaternions）</h4>
<p>为找出描述三维旋转的第二法，我们尝试把复数的概念扩展到三维空间。首先试着把 2 维的复数扩展为 3 维复数，但前人探索发现没有 3 维的,但存在 4 维・复数，, 称为四元数（quaternions)。</p>
<p>类比复数来构造四元数，复数只有一个虚单位 <span class="math inline">\(i,\)</span> 而四元数里定义三个虚单位，记作 <span class="math inline">\(i , j , k\)</span>，它们仍然满足</p>
<p>任意一个四元数 <span class="math inline">\(q\)</span> 表示为</p>
<p><span class="math display">\[
q=a 1+b i +c j +d k
\]</span></p>
<ul>
<li><strong>乘法</strong></li>
</ul>
<p>要想定义四元数间的乘法，必须定义虚单位间的乘法规则 <span class="math display">\[
ijk=-1
\]</span> 导出 <span class="math display">\[
\begin{aligned}
ijk&amp;=-1 \\ 
i j  kk &amp;=- k \\
ij &amp;= k 
\end{aligned}
\]</span></p>
<ul>
<li><strong>逆元</strong></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
q^{\dagger} q &amp; \stackrel{!}{=} 1\\ 
(a 1-b i -c j -d k )(a 1 +b i +c j +d k )&amp;=1\\
a^{2}+b^{2}+c^{2}+d^{2}&amp;=1
\end{aligned}
\]</span></p>
<p>就像单位复数构成一个群（群乘法为复数乘法）那样，单位四元数也<strong>构成一个群</strong>（群乘法为四元数乘法）。</p>
<h5 id="矩阵对应">矩阵对应</h5>
<p>类似于我们将二维复数与 <span class="math inline">\(2 \times 2\)</span> 实数矩阵建立联系的做法，四元数也可如此 - 将四个基 <span class="math inline">\(1, i , j , k\)</span> 与合适的矩阵一一对应。</p>
<p>其中一种方式（还有别的方式）是将它们与 <span class="math inline">\(2 \times 2\)</span>复数矩阵对应 <span class="math display">\[
\begin{aligned}
1=\left(\begin{array}{ll}
1 &amp; 0 \\
0 &amp; 1
\end{array}\right) \quad, \quad i =\left(\begin{array}{cc}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right)\\ 
j =\left(\begin{array}{ll}
0 &amp; i \\
i &amp; 0
\end{array}\right) \quad, \quad k =\left(\begin{array}{cc}
i &amp; 0 \\
0 &amp; -i
\end{array}\right)
\end{aligned}
\]</span> 不难验证上式满足四元数乘法，比如 <span class="math inline">\(i j=k\)</span> 、<span class="math inline">\(i j k=-1\)</span>式。</p>
<p>这样任意一个四元数都可用矩阵表示为: <span class="math display">\[
q=a 1+b i +c j +d k =\left(\begin{array}{cc}
a+d i &amp; b+c i \\
-b+c i &amp; a-d i
\end{array}\right)
\]</span></p>
<ul>
<li><span class="math inline">\(S U (2)\)</span></li>
</ul>
<p>因为 <span class="math inline">\(a^{2}+b^{2}+c^{2}+d^{2}=1\)</span>，比较可以发现单位四元数对应的矩阵的行列式为1。</p>
<ul>
<li><span class="math inline">\(U ^{\dagger} U =1\)</span> 幺正 unitary</li>
<li><span class="math inline">\(\operatorname{det}( U )=1\)</span></li>
</ul>
<p>任意单位四元数都唯一对应 <span class="math inline">\(S U (2)\)</span> 群中的一个群元。</p>
<blockquote>
<p><span class="math inline">\(S U (2)\)</span> 群如何与三维旋转联系？</p>
</blockquote>
<p>试将三维向量 <span class="math inline">\(\vec{v}=(x, y, z)\)</span> 定义为如下四元数 ： <span class="math display">\[
v \equiv x i +y j +z k
\]</span> 例：定义 u 是 <span class="math inline">\(R i + R j + R k\)</span> 的某一单位向量，则任意单位四元数 <span class="math inline">\(t\)</span> 可表示为: <span class="math display">\[
t=\cos \theta+u \sin \theta
\]</span> 任意三维向量 <span class="math inline">\(\vec{v}\)</span> 可表示为: <span class="math display">\[
\begin{aligned}
\vec{v}&amp;=\left(v_{x}, v_{y}, v_{z}\right)^{T}\\
&amp;=v_{x} i +v_{y} j +v_{z} k \\
&amp;{=} \left(\begin{array}{cc}
i v_{z} &amp; v_{x}+i v_{y} \\
-v_{x}+i v_{y} &amp; -i v_{z}
\end{array}\right)
\end{aligned}
\]</span> 简明起见我们举个特例，把向量 <span class="math inline">\(\vec{v}=(1,0,0)^{T}\)</span> 绕 <span class="math inline">\(z\)</span> 轴旋转。 <span class="math display">\[
\begin{aligned}
\vec{v}&amp;=(1,0,0)^{T} \\
\rightarrow v&amp;=1 i +0 j +0 k \\
&amp;=\left(\begin{array}{cc}
0 &amp; 1 \\
-1 &amp; 0
\end{array}\right)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
R_{z}(\theta)&amp;=\cos \theta 1+\sin \theta k \\&amp;=\left(\begin{array}{cc}
\cos \theta+i \sin \theta &amp; 0 \\
0 &amp; \cos \theta-i \sin \theta
\end{array}\right)
\end{aligned}
\]</span></p>
<p>用欧拉公式写出</p>
<p><span class="math display">\[
\begin{aligned}
e ^{i x}&amp;=\cos x+i \sin x \\
\Rightarrow R_{z}(\theta)&amp;=\left(\begin{array}{cc} 
e ^{i \theta} &amp; 0 \\
0 &amp; e ^{-i \theta}
\end{array}\right)
\end{aligned}
\]</span> 四元数旋转矩阵的逆矩阵为: <span class="math display">\[
\begin{aligned}
R_{z}^{-1}(\theta)&amp;=\left(\begin{array}{cc}
\cos \theta-i \sin \theta &amp; 0 \\
0 &amp; \cos \theta+i \sin \theta
\end{array}\right)\\
&amp;=\left(\begin{array}{cc} 
e ^{-i \theta} &amp; 0 \\
0 &amp; e ^{i \theta}
\end{array}\right)
\end{aligned}
\]</span> 根据 <span class="math inline">\(v^{\prime}=q^{-1} v q\)</span> 式旋转向量 <span class="math inline">\(v\)</span>;</p>
<p><span class="math display">\[
\begin{aligned}
v^{\prime} &amp;=R_{z}^{-1}(\theta) v R_{z}(\theta)\\
&amp;=\left(\begin{array}{cc} 
e ^{-i \theta} &amp; 0 \\
0 &amp; e ^{i \theta}
\end{array}\right)\left(\begin{array}{cc}
0 &amp; 1 \\
-1 &amp; 0
\end{array}\right)\left(\begin{array}{cc} 
e ^{i \theta} &amp; 0 \\
0 &amp; e ^{-i \theta}
\end{array}\right) \\
&amp;=\left(\begin{array}{cc}
0 &amp; e ^{-i 2 \theta} \\
- e ^{i 2 \theta} &amp; 0
\end{array}\right)\\
&amp;=\left(\begin{array}{ccc}
0 &amp; &amp; \cos (2 \theta)-i \sin (2 \theta) \\
-\cos (2 \theta)-i \sin (2 \theta) &amp; &amp; 0
\end{array}\right)
\end{aligned}
\]</span> 另一方面，向量 <span class="math inline">\(v^{\prime}\)</span> 用四元数表示为:</p>
<p><span class="math display">\[
v^{\prime}=\left(\begin{array}{cc}
i v_{z}^{\prime} &amp; v_{x}^{\prime}+i v_{y}^{\prime} \\
-v_{x}^{\prime}+i v_{y}^{\prime} &amp; -i v_{z}^{\prime}
\end{array}\right)
\]</span> 比较可得:</p>
<ul>
<li><span class="math inline">\(v_{x}^{\prime}=\cos (2 \theta)\)</span></li>
<li><span class="math inline">\(v_{y}^{\prime}=-\sin (2 \theta)\)</span></li>
<li><span class="math inline">\(v_{z}^{\prime}=0\)</span></li>
</ul>
<p>所以 <span class="math display">\[
\overrightarrow{v^{\prime}}=(\cos (2 \theta),-\sin (2 \theta), 0)^{T}
\]</span> 由上式可见从 <span class="math inline">\(\vec{v}\)</span> 到 <span class="math inline">\(\vec{v}^{\prime}\)</span> 确实进行了旋转</p>
<h5 id="双覆盖">双覆盖</h5>
<p>要注意，上式表示我们没有把 <span class="math inline">\(\vec{v}\)</span> 旋转 <span class="math inline">\(\theta\)</span> 角度，而是旋转了 <span class="math inline">\(2 \theta !\)</span> 因此我们定义 <span class="math inline">\(\phi \equiv 2 \theta\)</span> <span class="math display">\[
t=\cos \left(\frac{\phi}{2}\right)+\sin \left(\frac{\phi}{2}\right) u
\]</span> 这样定义的单位四元数与三维旋转矩阵之间的关系并非一一对应的，而是两个单位四元数描述同一个旋转，例如：</p>
<p>将向量旋转 <span class="math inline">\(\pi\)</span></p>
<ul>
<li><span class="math inline">\(t_{\phi=\pi}=u\)</span></li>
<li><span class="math inline">\(t_{\phi=3 \pi}=-u\)</span></li>
</ul>
<p>因此 <span class="math inline">\(S U (2)\)</span> 群称为 <span class="math inline">\(S O (3)\)</span> 群的双覆盖。一个 <span class="math inline">\(S U (2)\)</span> 中的群元对应 <span class="math inline">\(S O (3)\)</span>的哪个群元是很明确的，反过来就不行，因为 <span class="math inline">\(S O (3)\)</span> 中的一个群元对应 SU(2) 中的两个。这并非仅有数学意义，稍后就会看到，在物理上，一个能覆盖别的群的群往往更加深刻。</p>
<ul>
<li><strong>衔接</strong></li>
</ul>
<p>给定某个群，为了找出能覆盖这个群的群，我们需要学习 Lie代数 - Lie 理论的利器，下一节就讲 Lie 代数。</p>
<h3 id="lie-代数">Lie 代数</h3>
<p>Lie 理论是研究连续对称的理论。</p>
<p>圆的对称群（对称变换组成的群）是连续的，因为变换参数（旋转角）可以取任意（连续）的值。用数学符号来表示: 无限接近恒等元的群元 <span class="math inline">\(g\)</span> 可表示为: <span class="math display">\[
g(\epsilon)=I+\epsilon X
\]</span> 其中</p>
<ul>
<li><span class="math inline">\(I\)</span> 恒等元</li>
<li><span class="math inline">\(\epsilon\)</span> 表示小量（数学上总是用 <span class="math inline">\(\epsilon\)</span> 表示小量）</li>
<li><span class="math inline">\(X\)</span> 称为生成元，稍后就讨论它。</li>
</ul>
<p>这样一个轻微的小变换作用在对象上几乎舍也不变，有时称 <span class="math inline">\(g(\epsilon)\)</span> 为无穷小变换。把无穷小变换重复许多次就能得到一个有限大小的变换。 <span class="math display">\[
\begin{aligned}
h(\theta)&amp;= (I+\epsilon X)(I+\epsilon X) \ldots(I+\epsilon X)
\\&amp;=(I+\epsilon X)^{k}
\end{aligned}
\]</span> 其中 k 表示无穷小变换重复的次数。</p>
<h5 id="例子-3">例子</h5>
<p>如果 <span class="math inline">\(\theta\)</span> 表示有限大的旋转角，则无限接近于恒等变换的旋转变换可表示为：</p>
<p><span class="math display">\[
g\left(\frac{\theta}{N}\right)=I+\frac{\theta}{N} X
\]</span> 要使上式表示的变换尽可能小，则让 <span class="math inline">\(N\)</span> 尽可能大，令 <span class="math inline">\(N \rightarrow \infty\)</span> 。为了从这样一个无穷小变换得到一个有限变换，需要把无穷小变换重复无限多次，即: <span class="math display">\[
h(\theta)=\lim _{N \rightarrow \infty}\left(I+\frac{\theta}{N} X\right)^{N}= e ^{\theta X}
\]</span> 上式有 <span class="math inline">\(X\)</span> 生成了有限变换 <span class="math inline">\(h(\theta)\)</span> 的感觉，因此 <span class="math inline">\(X\)</span> 成为生成元。</p>
<h5 id="生成元">生成元</h5>
<p>考虑某个用矩阵表示的连续变换群，对任意群元，在恒等元 <span class="math inline">\(I\)</span> 处做 Taylor 展开 <span class="math display">\[
h(\theta)=I+\left.\frac{1}{1 !} \frac{d h}{d \theta}\right|_{\theta=0} \theta+\left.\frac{1}{2 !} \frac{d^{2} h}{d \theta^{2}}\right|_{\theta=0} \theta^{2}+\cdots=\left.\sum_{n} \frac{1}{n !} \frac{d^{n} h}{d \theta^{n}}\right|_{\theta=0} ^{n}
\]</span> 利用指数函数的级数展开可将上式的级数表示为更紧奏的形式 <span class="math display">\[
h(\theta)=\left.\exp \left(\left.\frac{d h}{d \theta}\right|_{\theta=0} \theta\right) \equiv \sum_{n} \frac{1}{n !} \frac{d^{n} h}{d \theta^{n}}\right|_{\theta=0} ^{\theta^{n}}
\]</span> 这与之前的描述有联系。比较 <span class="math display">\[
X=\left.\frac{d h}{d \theta}\right|_{\theta=0}
\]</span></p>
<blockquote>
<p>编含在上述推导中的思想是：通过研究群中重要的无穷小元素一生成元 <span class="math inline">\(X\)</span> 就能获得群的许多重要信息</p>
</blockquote>
<h4 id="矩阵-lie-群的-lie-代数">矩阵 Lie 群的 Lie 代数</h4>
<p>矩阵 Lie 群（记作 G）的 Lie 代数就是下面的集合: <span class="math display">\[
\left\{X \mid if \quad{\tilde{G}}{ e }^{X} \in G\right\}
\]</span> 即如果 X 满足 <span class="math inline">\(e ^{X}\)</span> 是 <span class="math inline">\(G\)</span> 的群元，则 <span class="math inline">\(X\)</span> 就是 <span class="math inline">\(G\)</span> 的 Lie 代数（它是一个集合!）中的元素。这个简单定义只对矩阵 Lie 群管用。之后我们引入 Lie 代数的一般定义。</p>
<p>上面的矩阵 Lie 群的 Lie 代数的定义用数学语言表述为 : <span class="math inline">\(n \times n\)</span> 矩阵 <span class="math inline">\(L i e\)</span> 群 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(L i e\)</span> 代数 <span class="math inline">\(g\)</span> 是满足如下条件的 <span class="math inline">\(n \times n\)</span> 矩阵 X 的集合: <span class="math display">\[
e ^{t X} \in G, t \in R
\]</span> 根据群的定义，群无非是一些变换的集合。群乘法 <span class="math inline">\(g \circ h\)</span> 告诉我们群元之间怎样结合。矩阵 Lie 群的群乘法就是矩阵乘法，我们可能naive 地认为 Lie 代数的元素之间采用相同的方式结合（$ $）</p>
<h5 id="bch-公式">BCH 公式</h5>
<p>但这并不正确！诚然，(矩阵 Lie 群的) Lie 代数的元素都是矩阵，但两个 Lie 代数的矩阵乘法的结果往往不再是 Lie 代数的元素。Lie代数元素间有另外的结合规则，当然它与原来群的群乘法直接有关。</p>
<p>Lie 群乘法与 Lie 代数结合法则之间的关系由著名的 Baker-Campbell-Hausdorff 公式（以下简称 BCH 公式）给出 <span class="math inline">\(^{39}\)</span> : <span class="math display">\[
\left. e ^{X} \circ e ^{Y}= e ^{X+Y+\frac{1}{2}[X, Y]+\frac{1}{12}[X,[X, Y]}\right]-\frac{1}{12}[Y,[X, Y]]+\ldots
\]</span> 其中 $ X, Y g ,$ 即 <span class="math inline">\(X, Y\)</span> 是群 <span class="math inline">\(G\)</span> 的生成元。 <span class="math inline">\(e ^{X}, e ^{Y}\)</span> 是 <span class="math inline">\(G\)</span> 的群元，把它们分别记作 <span class="math inline">\(g, h,\)</span> 这样上式写成: <span class="math display">\[
 {g}  \circ {h} = e ^{X} \circ e ^{Y}= \left. e ^{X+Y+\frac{1}{2}[X, Y]+\frac{1}{12}[X,[X, Y]}\right]-\frac{1}{12}[Y,[X, Y]]+\ldots 
\]</span> 上式等号右侧是群的一个群元，可见两个群元<span class="math inline">\((g, h)\)</span>相乘可表示为一些 Lie 代数元素的和（再取指数）。上两式出现的新运算 [, ] 称为 Lie 括号，对于矩阵 Lie 群, <span class="math inline">\([X, Y]\)</span> 称为 <span class="math inline">\(X, Y\)</span> 的对易子。 <span class="math display">\[
[X, Y]=X Y-Y X
\]</span> 注意 <span class="math inline">\(X Y\)</span> 和 <span class="math inline">\(Y X\)</span> 一般不是 Lie 代数的元素，但它们的差一定是！</p>
<p>由 BCH 公式可知 Lie 代数元素间的乘法规则是 Lie 括号 [, ]而非最初认为的矩阵乘法。就像群在群乘法。运算（矩阵群的 o就是矩阵乘法）下封闭那样，我们称 Lie 代数在 Lie 括号运算下封闭。集合在某运算下封闭的含义是集合的任意两个元素进行该运算所得结果仍在此集合内。</p>
<ul>
<li>衔接</li>
</ul>
<p>在学习一个 Lie 代数的例子之后，我们将讨论 Lie 代数的现代定义。现代定义是从群的生成元在 Lie 括号运算下的行为来定义的。利用更广泛的现代定义就能看出哪些不同的群具有相同的 Lie代数，只从上面的 Lie 代数定义出发看不出这一点来。因此 Lie 代数的新定义能让我们更深刻地认识一种变换的基本特征。同一 Lie代数可对应许多 Lie 群，Lie 理论的一条重要定理告诉我们这其中有一个特别的 Lie 群。引入 Lie 群的现代定义之后上面所说的就具体起来了。</p>
<p>下面我们就举一个从给定的群导出相应 Lie 代数的例子。</p>
<h4 id="s-o-3-群的生成元与-lie-代数"><span class="math inline">\(S O (3)\)</span> 群的生成元与 Lie 代数</h4>
<p><span class="math inline">\(S O (3)\)</span> 群的定义 <span class="math display">\[
O ^{T} O \stackrel{!}{=} I, \quad \operatorname{det}( O ) \stackrel{!}{=} 1
\]</span> 任意群元 <span class="math inline">\(O\)</span> 用相应的生成元 <span class="math inline">\(J\)</span> 表示为:</p>
<p><span class="math display">\[
O = e ^{\phi J}
\]</span></p>
<p>把 <span class="math inline">\(O = e ^{\phi J}\)</span> 带入群的第一个定义条件得: <span class="math display">\[
O ^{T} O = e ^{\phi J^{T}} e ^{\phi J} \stackrel{!}{=1} \\
\rightarrow \quad J^{T}+Y \stackrel{!}{=} 0
\]</span> 带入第二个定义条件，再利用等式 $ ( e ^{A})= e ^{(A)}$ 得</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\operatorname{det}( O ) \stackrel{!}{=} 1 \\&amp; \rightarrow \operatorname{det}\left( e ^{\phi J}\right)= e ^{\phi \operatorname{tr}(J)} \stackrel{!}{=} 1 \\
&amp; \rightarrow \operatorname{tr}(J) \stackrel{!}{=} 0
\end{aligned}
\]</span></p>
<h5 id="群的生成元的基">群的生成元的基</h5>
<p>满足 <span class="math inline">\(J^{T}+J \stackrel{!}{=} 0\)</span> 和 <span class="math inline">\(\operatorname{tr}(J) \stackrel{!}{=} 0\)</span> 的三个线性无关的矩阵 <span class="math display">\[
J_{1}=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 \\
0 &amp; 1 &amp; 0
\end{array}\right)
\\
J_{2}=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 \\
-1 &amp; 0 &amp; 0
\end{array}\right)
\\
J_{3}=\left(\begin{array}{ccc}
0 &amp; -1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{array}\right)
\]</span> 这三个矩阵构成 <span class="math inline">\(SO (3)\)</span> 群的生成元的基。即群的任意生成元 <span class="math inline">\(J\)</span> 可惟一表示为这三者的线性组合: <span class="math display">\[
J=a J_{1}+b J_{2}+c J_{3}
\]</span> 其中 <span class="math inline">\(a, b, c\)</span> 表示实常数。 <span class="math inline">\(J_{1}, J_{2}, J_{3}\)</span> 可用 Levi-Civita 符号更紧奏地表示 : <span class="math display">\[
\left(J_{i}\right)_{j k}=-\epsilon_{i j k}, \quad i, j, k=1,2,3
\]</span> 其中 <span class="math inline">\(j, k\)</span> 表示生成元 的<span class="math inline">\(J_{i}\)</span> 分量。例: <span class="math display">\[
\begin{aligned}
\left(J_{1}\right)_{j k}&amp;=-\epsilon_{1 j k} \longleftrightarrow\left(\begin{array}{lll}
\left(J_{1}\right)_{11} &amp; \left(J_{1}\right)_{12} &amp; \left(J_{1}\right)_{13} \\
\left(J_{1}\right)_{21} &amp; \left(J_{1}\right)_{22} &amp; \left(J_{1}\right)_{23} \\
\left(J_{1}\right)_{31} &amp; \left(J_{1}\right)_{32} &amp; \left(J_{1}\right)_{33}
\end{array}\right) \\
&amp; =-\left(\begin{array}{ccc}
\epsilon_{111} &amp; \epsilon_{112} &amp; \epsilon_{113} \\
\epsilon_{121} &amp; \epsilon_{122} &amp; \epsilon_{123} \\
\epsilon_{131} &amp; \epsilon_{132} &amp; \epsilon_{133}
\end{array}\right)\\&amp;=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 \\
0 &amp; 1 &amp; 0
\end{array}\right)
\end{aligned}
\]</span> 这些生成元可以生成有限大小的变换矩阵。</p>
<h5 id="例子-4">例子</h5>
<p>以 <span class="math inline">\(J_{1}\)</span> 为例，我们可以只关注非零部分 一 右下角的 <span class="math inline">\(2 \times 2\)</span> 矩阵，把它记作 <span class="math inline">\(j_{1}\)</span> 。 <span class="math display">\[
J_{1}=\left(\begin{array}{cc}0 &amp;  \\   &amp; j_{1}\end{array}\right)=\left(\begin{array}{cc}0 &amp;  \\   &amp; \left(\begin{array}{cc}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right)\end{array}\right)
\]</span> 计算可得 <span class="math display">\[
j_{1}^{2}=-1
\]</span> 接着: <span class="math display">\[
j_{1}^{3}= j_{1}^{2}  j_{1}=-j_{1}\\
j_{1}^{4}=+1\\ 
j_{1}^{5}=+j_{1}
\]</span> 一般情况为: <span class="math display">\[
j_{1}^{2 n}=(-1)^{n} I\\ j_{1}^{2 n+1}=(-1)^{n} j_{1}
\]</span> 利用上式可计算 <span class="math inline">\(j_{1}\)</span> 的指数函数的级数展开： <span class="math display">\[
\begin{aligned}
R_{1} &amp;= e ^{\phi j_{1}}=\sum_{n=0}^{\infty} \frac{\phi^{n} j_{1}^{n}}{n !} \\
&amp;=\sum_{n=0}^{\infty} \frac{\phi^{2 n}}{(2 n) !} 
{j_{1}^{2 n}}
+\sum_{n=0}^{\infty} \frac{\phi^{2 n+1}}{(2 n+1) !} 
j_{1}^{2 n+1}
\\
&amp;=\left(\sum_{n=0}^{\infty} \frac{\phi^{2 n}}{(2 n) !}(-1)^{n}\right) I+
\left(\sum_{n=0}^{\infty} \frac{\phi^{2 n+1}}{(2 n+1) !}(-1)^{n}\right)j_{1} \\
&amp;=\cos \phi\left(\begin{array}{ll}
1 &amp; 0 \\
0 &amp; 1
\end{array}\right)+\sin \phi\left(\begin{array}{c}
0 &amp; -1 \\
1 &amp; 0
\end{array}\right)
\\&amp;=\left(\begin{array}{cc}
\cos \phi &amp; -\sin \phi \\
\sin \phi &amp; \cos \phi
\end{array}\right)
\end{aligned}
\]</span> 再利用 <span class="math inline">\(e ^{0}=1\)</span>计算左上角的 0 对应的元素，得到完整的有限变换矩阵: <span class="math display">\[
R_{1}=\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos \phi &amp; -\sin \phi \\
0 &amp; \sin \phi &amp; \cos \phi
\end{array}\right)
\]</span></p>
<h5 id="导出生成元">导出生成元</h5>
<p>我们己经得出 <span class="math inline">\(SO (3)\)</span> 群的生成元显式的矩阵形式 <span class="math display">\[
J_{1}=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 \\
0 &amp; 1 &amp; 0
\end{array}\right)
\\
J_{2}=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 \\
-1 &amp; 0 &amp; 0
\end{array}\right)
\\
J_{3}=\left(\begin{array}{ccc}
0 &amp; -1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{array}\right)
\]</span> 这样就能直接计算生成元之间的 Lie 括号了，不难得到： <span class="math display">\[
\left[J_{i}, J_{j}\right]=\epsilon_{i j k} J_{k}
\]</span> 其中 <span class="math inline">\(\epsilon_{i j k}\)</span> 是 Levi-Civita 符号。</p>
<p>出于物理层面的考虑，在 <span class="math inline">\(S O (3)\)</span> 生成元 <span class="math inline">\(e ^{\phi J}\)</span> 的审附加一个虚 单位 <span class="math inline">\(i,\)</span> 即 e <span class="math inline">\(^{i \phi J},\)</span> 生成元的基变成: <span class="math display">\[
J_{1}=i\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
0 &amp; -1 &amp; 0
\end{array}\right)
\\J_{2}=i\left(\begin{array}{ccc}
0 &amp; 0 &amp; -1 \\
0 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0
\end{array}\right)
\\J_{3}=i\left(\begin{array}{ccc}
0 &amp; 1 &amp; 0 \\
-1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{array}\right)
\]</span> 于是 Lie 代数为: <span class="math display">\[
\left[J_{i}, J_{j}\right]=i \epsilon_{i j k} J_{k}
\]</span> 将生成元加 <span class="math inline">\(i\)</span> 是为了让它们是厄米生成元，厄米生成元的含 义是 <span class="math inline">\(J^{\dagger} \equiv\left(J^{*}\right)^{T} \stackrel{!}{=} J_{\text {。 }}\)</span> 加 <span class="math inline">\(i\)</span> 是从物理意义考虑的: 厄米矩阵的本征值都是实数，这在量子力学里面极其重要，因为生成元的本征值是实验的可观测量。如果不加 <span class="math inline">\(i\)</span>，生成元就是反厄米的了: <span class="math inline">\(J^{\dagger}=\left(J^{*}\right)^{T}=-J,\)</span> 反厄米矩阵的本征值是虚数。</p>
<h5 id="另一种导出生成元">另一种导出生成元</h5>
<p>还有另一种导出生成元的方法, 利用 <span class="math display">\[
-X=\left.\frac{d h}{d \theta}\right|_{\theta=0}
\]</span> 以及三维旋转矩阵的形式 <span class="math display">\[
R_{1}=\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos \phi &amp; -\sin \phi \\
0 &amp; \sin \phi &amp; \cos \phi
\end{array}\right)
\]</span> 可得: <span class="math display">\[
\begin{aligned}
J_{1}=&amp;\left.\frac{d R_{1}}{d \theta}\right|_{\theta=0}\\&amp;=\left.\frac{d}{d \theta}\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos \theta &amp; -\sin \theta \\
0 &amp; \sin \theta &amp; \cos \theta
\end{array}\right)\right|_{\theta=0} \\
&amp;=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0 \\
0 &amp; -\sin \theta &amp; -\cos \theta \\
0 &amp; \cos \theta &amp; -\sin \theta
\end{array}\right) \\&amp;=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 \\
0 &amp; 1 &amp; 0
\end{array}\right)
\end{aligned}
\]</span> 第一种方法更加普遍，因为像这样已知有限变换矩阵具体形式的好事不太常见。对于之后的Lorentz 群，我们先根据群的定义导出其生成元的基，然后才得出 Lorentz 变换的显式形式。当然如果已知变换矩阵形式那么这种就能最简便地导出生成元。</p>
<h4 id="lie-代数的抽象定义">Lie 代数的抽象定义</h4>
<p>前面介绍了简化版的 Lie 代数定义。群 G 的 Lie 代数是满足如下条件的 X 的集合: <span class="math inline">\(e ^{X} \in G_{\circ}\)</span> 下面我们会看到，群的重要部分 一 群乘法（规定群元之间怎样结合），可以从 Lie 代数元素的Lie 括号运算中导出。 就像定义 Lie 群那样，我们把 Lie 代数的关键特征表示为公理，这就形成了 Lie 代数的抽象定义:</p>
<blockquote>
<p>Lie 代数是一个向量空间 g 配备一个二元运算 <span class="math inline">\([,]: g \times g \rightarrow g ,\)</span> 且二元运算 [, ] 满足如下公理：</p>
<ul>
<li><p>双线 $ a, b R$ 及 <span class="math inline">\(\forall X\)</span>,$ Y$, <span class="math inline">\(Z\in g\)</span>，<span class="math inline">\([a X+b Y, Z]=a[X, Z]+b[Y, Z]\)</span>，<span class="math inline">\([Z, a X+b Y]=a[Z, X]+b[Z, Y]\)</span></p></li>
<li><p>反交换律: <span class="math inline">\(\forall X, Y \in g ,[X, Y]=-[Y, X]\)</span></p></li>
<li><p>$ J a c o b i$ 恒等： $ X, Y, Z g ,$<span class="math inline">\([X,[Y, Z]]+[Z,[X, Y]]+[Y,[Z, X]]=0\)</span></p></li>
</ul>
</blockquote>
<p>之前我们把矩阵的对易子作为 Lie 代数的二元运算 [, ]，不难验证对易子满足上面的要求。其实有许多和对易子丝毫不同的二元运算照样满足这些公理，比如经典力学中著名的 Poisson 括号。</p>
<p>注意 Lie 代数的抽象定义完全不依赖群，这十分重要要。</p>
<h3 id="s-u-2-的生成元与lie-代数"><span class="math inline">\(S U (2)\)</span> 的生成元与Lie 代数</h3>
<p>前面我们历经磨难终于找到描述三维旋转的第二法 - <span class="math inline">\(S U (2)\)</span>群，并且发现 <span class="math inline">\(S U (2)\)</span> 是 <span class="math inline">\(S O (3)\)</span> 的双覆盖 。</p>
<h4 id="su2-的生成元pauli-矩阵">SU(2) 的生成元:Pauli 矩阵</h4>
<p><span class="math inline">\(S U (2)\)</span> 群的群元是具有单位行列式 的幺正的 <span class="math inline">\(2 \times 2\)</span> 矩阵，即： <span class="math display">\[
\begin{aligned}
U ^{\dagger} U &amp;= U U ^{\dagger}=1 \\
&amp; \operatorname{det}( U )=1
\end{aligned}
\]</span> 从群元满足的条件可导出其生成元满足的条件。设生成元为 $J_{1}, J_{2}, $ 将群元用生成元表示，带入上两式 ： <span class="math display">\[
\begin{aligned}
&amp;U ^{\dagger} U =\left( e ^{i J_{i}}\right)^{\dagger} e ^{i J_{i}} \stackrel{!}{=1} \\
&amp;\operatorname{det}( U )=\operatorname{det}\left( e ^{i J_{i}}\right) \stackrel{!}{=} 1
\end{aligned}
\]</span> 结合 <span class="math inline">\(\left( e ^{i J_{i}}\right)^{\dagger} e ^{i J_{i}} \stackrel{!}{=} 1\)</span>，BCH 公式和 <span class="math inline">\(\left[J_{i}, J_{i}\right]=0^{}:\)</span> <span class="math display">\[
\begin{aligned}
\left( e ^{i J_{i}}\right)^{\dagger} e ^{i J_{i}}&amp;= 1\\
e ^{-i J_{i}^{\dagger}} e ^{i J_{i}}&amp; \stackrel{!}{=} 1\\
e ^{-i J_{i}^{\dagger}}+i J_{i}+\frac{1}{2}\left[J_{i}^{\dagger}, J_{i}\right]+\ldots &amp;\stackrel{!}{=} 1\\
-i J_{i}^{\dagger}+i J_{i}&amp;=0\\
J_{i}^{\dagger}&amp; \stackrel{!}{=} J_{i}
\end{aligned}
\]</span> 满足 <span class="math inline">\(J_{i}^{\dagger}=J_{i}\)</span> 的矩阵称为厄米矩阵，由上可见 <span class="math inline">\(S U (2)\)</span> 的生成元必须是厄米的。</p>
<p>利用恒等式 $( e ^{A})= e ^{(A) } $ 和<span class="math inline">\(\operatorname{det}\left( e ^{i J_{i}}\right) \stackrel{!}{=} 1\)</span>式可得: <span class="math display">\[
\begin{aligned}
\operatorname{det}\left( e ^{i J_{i}}\right)= 1\\e ^{i \operatorname{tr}\left(J_{i}\right)}=1 \\
\operatorname{tr}\left(J_{i}\right) \stackrel{!}{=} 0
\end{aligned}
\]</span> 综上， SU(2) 的生成元一定是无迹的厄米矩阵。<span class="math inline">\(2 \times 2\)</span> 无迹厄米矩阵的一组基为： <span class="math display">\[
\sigma_{1}=\left(\begin{array}{cc}
0 &amp; 1 \\
1 &amp; 0
\end{array}\right)
\\
\sigma_{2}=\left(\begin{array}{cc}
0 &amp; -i \\
i &amp; 0
\end{array}\right)\\
\sigma_{3}=\left(\begin{array}{cc}
1 &amp; 0 \\
0 &amp; -1
\end{array}\right)
\]</span> 也就是说任意 <span class="math inline">\(2 \times 2\)</span> 无迹厄米矩阵都可唯一表示为上面三个矩阵的线性组合。这三个矩阵称为 Pauli 矩阵。</p>
<h4 id="对易关系">对易关系</h4>
<p>把 Pauli 矩阵扬进 Lie 括号中进行计算可得: <span class="math display">\[
\left[\sigma_{i}, \sigma_{j}\right]=2 i \epsilon_{i j k} \sigma_{k}
\]</span> 其中 <span class="math inline">\(\epsilon_{i j k}\)</span> 是 Levi-Civita 符号。上式右侧的 2 很多余，因此通常将 <span class="math inline">\(S U (2)\)</span> 的生成元的基定义为 <span class="math inline">\(J_{i} \equiv \frac{1}{2} \sigma_{i},\)</span> 这样 Lie 括号计算结果为: <span class="math display">\[
\left[J_{i}, J_{j}\right]=i \epsilon_{i j k} J_{k}
\]</span> 注意这与 <span class="math inline">\(S O (3)\)</span> 的生成元形式 ( (3.73) 式)相同!因此我们说 <span class="math inline">\(S U (2)\)</span> 与 <span class="math inline">\(S O (3)\)</span> 有相同的 Lie 代数，因为 Lie 代数是通过 Lie 括号定义</p>
<p>利用 Lie 代数的抽象定义可以用不同的方式描述 SU(2) 群对应的变换，即，<span class="math inline">\(S U(2)\)</span> 群对应的变换可以不用 <span class="math inline">\(2 \times 2\)</span> 矩阵表示。为了做到这一点，我们还需要知道 Lie 群的抽象定义。因为一直以来就是用 <span class="math inline">\(2 \times 2\)</span> 矩阵定义 <span class="math inline">\(S U(2)\)</span> 的，换一种表示方法(例如用 <span class="math inline">\(3 \times 3\)</span> 矩阵表示) 则不知所云。Lie 群的抽象定义能够让我们发现同一变换的不同表示之间的关系。抽象定义将 Lie 群与一种几何结构 一 流形相等同，利用这种抽象结构来定义一个群。这一想法初看十分怪异，但在学习两个例子之后就会发现它是超级有意义的。</p>
<h3 id="lie-群的抽象定义">Lie 群的抽象定义</h3>
<h5 id="u-1-与-s-o-2"><span class="math inline">\(U (1)\)</span> 与 <span class="math inline">\(S O (2)\)</span></h5>
<p>纯良的 U(1) 群，它由全体单位复数构成。定义为 <span class="math inline">\(z^{*} z=1,\)</span> 设 <span class="math inline">\(z=a+i b,\)</span> 则 : <span class="math display">\[
\begin{aligned}
z^{*} z&amp;=(a+i b)^{*}(a+i b)\\&amp;=(a-i b)(a+i b)\\&amp;=a^{2}+b^{2}\\&amp;=1
\end{aligned}
\]</span> 这也是单位圆的定义条件。可见单位复数的集合正是复平面上的单位圆。此外，我们知道 <span class="math inline">\(U (1)\)</span> 与 <span class="math inline">\(S O (2)\)</span> 群间存在一一映射 。 因此这两个群可以与几何对象 一单位圆 一 视为等同。群的抽象定义并非将这个群用 SO(2)，或着是不同的 U(1) 体现，因为它们都是由特定维数的对象定义的。可以将该群直接利用单位圆定义。即二维旋转变换（对应的 Lie 群）等同于单位圆，然后我们可以用<span class="math inline">\(S O (2)\)</span> 群表示这个变换（<span class="math inline">\(2 \times 2\)</span> 矩阵)，也可用 U(1) 群来表示（单 位复数）。</p>
<h5 id="s-o-3-与-s-u-2">$ S O (3)$ 与 $S U (2) $</h5>
<p>下面讨论升级版 $ S O (3)$ 与 $S U (2) $。 前面讲过在 <span class="math inline">\(S U (2)\)</span> 与 单位四元数之间有一一映射。单位四元数就是满足下列条件的一般四元数 <span class="math inline">\(q=a 1+b i +c j +d k :\)</span> <span class="math display">\[
a^{2}+b^{2}+c^{2}+d^{2} \stackrel{!}{=} 1
\]</span> 这与三维超球面 <span class="math inline">\(S^{3}\)</span> 的定义相同！上式给出了一个 <span class="math inline">\(S U (2)\)</span> 与 <span class="math inline">\(S^{3}\)</span> 之间的映射，该映射是同构映射（是单射也是满射），因此我们可以把 <span class="math inline">\(S U (2)\)</span> 与三维超球面 <span class="math inline">\(S^{3}\)</span> 等同。</p>
<h4 id="lie-群的现代定义">Lie 群的现代定义</h4>
<p>结合上面的例子，Lie 群的现代定义就不难理解了：</p>
<blockquote>
<p>Lie 群是一个群，也是一个微分流形60。当然，这个流形要满足如下条件:</p>
<ul>
<li>群乘法 $ $ 诱导出的从流形到流形自身的映射必须是可微的。这称为相容性条件，它保证了群定义与流形定义的兼容。例如，群<span class="math inline">\(G\)</span> 的任意群元 <span class="math inline">\(a\)</span>诱导出了从 <span class="math inline">\(G\)</span> 到 <span class="math inline">\(G\)</span> 的映射: 给定 <span class="math inline">\(\forall b \in G\)</span>，<span class="math inline">\(c \equiv a \circ b \in G,\)</span> 映射 <span class="math inline">\(a: G \rightarrow G^{32}\)</span> 必须是可微的</li>
<li>流形中的任意点都有相应的坐标，可以用坐标的语言表示上述内容: <span class="math inline">\(c=a b\)</span> 对应的坐标必须是 <span class="math inline">\(b\)</span> 的坐标的可微函数。</li>
</ul>
</blockquote>
<p>从 Lie 代数的抽象定义可以看出 <span class="math inline">\(S O (3)\)</span> 与 <span class="math inline">\(S U (2)\)</span> 有相同的Lie 代数，现在有了 Lie 群的抽象定义，我们可以得出一个重要的结论</p>
<blockquote>
<p><strong>任一 Lie 代数仅对应一个单连通 Lie 群。</strong></p>
</blockquote>
<p>为什么有一个特别的群？因为这个特别的群是<strong>单连通</strong>的。单连通性是流形的性质，它的含义是流形上的任意闭合曲线可以平滑地<strong>收缩为一点</strong>。只有通过现代定义将群与流形联系起来才能找出特别的群。</p>
<h5 id="覆盖群">覆盖群</h5>
<p>给定 Lie 代数，它可<strong>对应许多</strong> Lie 群，而其中唯一的单连通Lie 群可以视为其他群的“<strong>母体</strong>”，因为总存在从这个单连通群到其他群的映射，反之则不一定。何妨把这个单连通群称为母群呢？数学家们给它起了一个不太文艺的名字: 覆盖群。并且称该群覆盖了同一 Lie 代数对应的其他群。</p>
<p>我们已经遭遇过这种情况：<span class="math inline">\(S U(2)\)</span>群是 <span class="math inline">\(S O (3)\)</span> 群的双覆盖，即两个 <span class="math inline">\(S U (2)\)</span> 元素对应一个 <span class="math inline">\(S O (3)\)</span> 的元素。</p>
<p><span class="math inline">\(S U (2)\)</span> 就是三维超球面，它正是一个单连通流形。因此 Lie 代 数 <span class="math inline">\(\left[J_{i}, J_{j}\right]=i \epsilon_{i j k} J_{k}\)</span> 式对应的覆盖群就是 <span class="math inline">\(S U (2)\)</span> 。从 <span class="math inline">\(S U (2)\)</span> 出发可以构造出其他所有对应的群。</p>
<p><img src="https://jptanjing.oss-cn-beijing.aliyuncs.com/img/image-20200930145339066.png" srcset="/img/loading.gif" /></p>
<p><span class="math inline">\(S O (3)\)</span> 是什么流形？已知 <span class="math inline">\(S U (2)\)</span> 到 <span class="math inline">\(S O (3)\)</span> 的映射将 <span class="math inline">\(S U (2)\)</span> 的两个点映射为 <span class="math inline">\(S O (3)\)</span> 中的一个。因此 <span class="math inline">\(S O (3)\)</span> 是单位超球面的一半。</p>
<h5 id="流形">流形</h5>
<p>因此从流形的角度看，<span class="math inline">\(SU (2)\)</span> 群比 <span class="math inline">\(SO (3)\)</span>更完整，<span class="math inline">\(SO (3)\)</span> 只 是其中的一部分。 本书的指导思想之一就是用最基本的群描述大自然最基本的对称性。具体到三维旋转的情况，我们采用 <span class="math inline">\(S U (2)\)</span> 而非 $S O (3) $ 。之后其他的对称性我们都这么处理。 世界似乎就是这么设计的！比如必须用 Poincaré 群的双覆盖表示来描述基本粒子，而常用却不完整的 4-向量表示就不行。要从最深刻的层面描述自然，必须使用覆盖群，而非从覆盖群导出的其他群。</p>
<p>给定一个 Lie 代数，我们可以通过 Lie 代数的表示来导出它的覆盖群的表示，然后把 Lie 代数元素（生成元）的矩阵表示扮进 e 指数里面就能得到任意群元的矩阵表示。</p>
<p>这就是 Lie 理论的威力所在。人类通过纯数学就能揭示自然的某些深刻规律。狭义相对论的标准对称群隐藏了一些真相，因为它（尽管常用）不是这一对称性对应的最基本的覆盖群。Poincaré群的覆盖群才是最基本的，我们用它描述自然。</p>
<p>总结一下 : <span class="math display">\[
S^{1} \hat{=} U (1) {\leftrightarrows}    S O (2)
\]</span></p>
<p><span class="math display">\[
S^{3}\hat{=} S U (2) {\longrightarrow}  S O (3) \hat{=} S^{3} \text { 的一半 }
\]</span></p>
<p><span class="math inline">\(\Rightarrow S U (2)\)</span> 是 <span class="math inline">\(\operatorname{Lie}\)</span> 代数 <span class="math inline">\(\left[J_{i}, J_{j}\right]=i \epsilon_{ijk} J_{k}\)</span> 的覆盖群，因为 <span class="math inline">\(S^{3}\)</span> 是单连通流形。</p>
<ul>
<li><strong>衔接</strong></li>
</ul>
<p>下一节介绍 Lie 理论的重要分支 一表示论。表示论使我们能够从任意 Lie 群导出相应基本群。</p>
<h2 id="representation-theory-表示论">Representation Theory 表示论</h2>
<blockquote>
<p>群论可以描述变换本身而<strong>不必联系</strong>现实中的特定对象，这是群论的重要特征。</p>
</blockquote>
<p>理论上经常从抽象观点来考虑一个群。这意味着用流形结构与群乘法定义群。例如 <span class="math inline">\(S U (2)\)</span> 就是 <span class="math inline">\(S^{3}(\)</span> 超球面)，群元就是流形中 的点，群乘法规定两个群元 <span class="math inline">\(a, b\)</span> 怎样结合，且满足群公理。搞物理 的更关心一个群到底能做什么，即<strong>群作用</strong>。</p>
<h3 id="定义">定义</h3>
<p>同一个群能<strong>作用于</strong>许多不同种类的东西，这一重要事实使我们定义了<strong>表示</strong>的概念:</p>
<blockquote>
<p>群 <span class="math inline">\(G\)</span> 的一个表示就是从 <span class="math inline">\(G\)</span> 到某个向量空间 <span class="math inline">\(V\)</span> 上全体线性变换组成的集合的映射，将表示记作 R, 映射 <span class="math display">\[
R:  {g}  \mapsto R(g)
\]</span> 其中 <span class="math inline">\(R(g)\)</span> 表示 <span class="math inline">\(V\)</span> 上的某个线性变换。映射 <span class="math inline">\(R\)</span> 必须满足如下条件</p>
<ul>
<li><span class="math inline">\(R(e)=I,\)</span> 恒等元对应的线性变换是恒等变换。</li>
<li><span class="math inline">\(R \left(g^{-1}\right)=(R(g))^{-1},\)</span> 逆元对应的变换是逆变换。</li>
<li>$ R(g) R(h)=R(g h),$ 群元 <span class="math inline">\(g, h\)</span> 结合对应的变换等于他们 分别对应变换的结合。</li>
</ul>
</blockquote>
<h4 id="表示论与线性变换">表示论与线性变换</h4>
<p><strong>群的表示将抽象的群元（群流形上的点）与向量空间中的线性变换相联系。</strong>尽管按定义来讲，表示是个映射，但大多数情况把表示看做许多<strong>矩阵的集合</strong>就行了。例如：</p>
<ul>
<li>向量空间 <span class="math inline">\(R ^{3}\)</span> 中的旋转矩阵组成的集合就是 <span class="math inline">\(SO (3)\)</span> 群的一个表示，旋转矩阵就是 <span class="math inline">\(R ^{3}\)</span> 的线性变换。注意 <span class="math inline">\(SO (3)\)</span> 群对应的变换也可以作用到其他向量空间。</li>
</ul>
<p>表示论让我们能系统研究同一个群对不同向量空间的作用, 这让群论<strong>变得精彩</strong>多了。</p>
<h3 id="例子-s-u-2">例子 <span class="math inline">\(S U (2)\)</span></h3>
<p><span class="math inline">\(S U (2)\)</span> 是在物理里最常用的群之一。它可以作用到许多向量 空间上</p>
<ul>
<li>比如作用于一维复数向量空间 <span class="math inline">\(C^{1}\)</span>，稍后会看到结果是很平凡的。</li>
<li>再比如作用于 <span class="math inline">\(C^{2}\)</span> 下面我们会详细探究这种作用，<span class="math inline">\(C^{2}\)</span> 的元素是二维复数向量，因此 <span class="math inline">\(S U (2)\)</span> 的群元以 <span class="math inline">\(2 \times 2\)</span> 复数矩阵的形式出现，这是 <span class="math inline">\(S U (2)\)</span> 最常用的表示，之前一直采用此表示。</li>
<li><span class="math inline">\(S U (2)\)</span> 还可作用到<span class="math inline">\(C^{3}\)</span> ，前人已经对此有完备的研究，<span class="math inline">\(S U (2)\)</span> 作用于 3 维复向量的时候以 <span class="math inline">\(3 \times 3\)</span> 矩阵的形式出现。剧透: <span class="math inline">\(S U (2)\)</span> 的 <span class="math inline">\(C^{3}\)</span> 版本的生成元是</li>
</ul>
<p><span class="math display">\[
J_{1}=\frac{1}{\sqrt{2}}\left(\begin{array}{lll}
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0
\end{array}\right)\\
J_{2}=\frac{1}{\sqrt{2}}\left(\begin{array}{ccc}
0 &amp; -i &amp; 0 \\
i &amp; 0 &amp; -i \\
0 &amp; i &amp; 0
\end{array}\right)\\
J_{3}=\frac{1}{\sqrt{2}}\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1
\end{array}\right)
\]</span></p>
<p>下面会把 <span class="math inline">\(S U (2)\)</span> 的群元写成 <span class="math inline">\(3 \times 3\)</span> 矩阵的形式，因此要牢记当谈论一般情况 <span class="math inline">\(S U (2)\)</span> 或其他群群元的时候，我们指的是抽象的群流形中的点，而非只是 <span class="math inline">\(2 \times 2\)</span> 矩阵或者别的。</p>
<p>本章前面都是从群的某个表示出发定义一个群的。比如用<span class="math inline">\(2 \times 2\)</span> 矩阵定义 <span class="math inline">\(S U (2)\)</span>，此方法的优点是群的含义十分具体。在入门之后，把群视为抽象流形的观点74更有效，因为这样可以更方便地找出其他有用的群表示。</p>
<h3 id="表示的等级有关的概念">表示的“等级”有关的概念</h3>
<h4 id="相似变换">相似变换</h4>
<p>首先是相似变换。给定任意矩阵 <span class="math inline">\(R\)</span> 与可逆矩阵 <span class="math inline">\(S\)</span>。则通过可逆矩阵进行相似变换得到: <span class="math display">\[
R \rightarrow R^{\prime}=S^{-1} R S
\]</span> 相似变换与表示的关系在于</p>
<ul>
<li>给定群 <span class="math inline">\(G\)</span></li>
<li>群的表示 <span class="math inline">\(R(G)\)</span></li>
<li>任意可逆矩阵 <span class="math inline">\(S\)</span></li>
</ul>
<p>则 <span class="math inline">\(S^{-1} R S\)</span> 也是群表示。</p>
<p>这可以从群的定义直接看出来: <span class="math inline">\(\forall g_{1}, g_{2} \in G,\)</span> 表示 <span class="math inline">\(R\)</span> 把群元映射为向量空间 <span class="math inline">\(V\)</span> 上的线性变换 $R(g_{1}), R(g_{2}) $。 群的定义要求 <span class="math display">\[
R\left(g_{1}\right) R\left(g_{2}\right)=R\left(g_{1} g_{2}\right)
\]</span> 现在把表示进行相似变换： <span class="math display">\[
\begin{aligned}
&amp;S^{-1} R\left(g_{1}\right) {S S^{-1}}  R\left(g_{2}\right) S\\=&amp;S^{-1} R\left(g_{1}\right) R\left(g_{2}\right) S\\=&amp;S^{-1} R\left(g_{1} g_{2}\right) S
\end{aligned}
\]</span> 上式可得 <span class="math inline">\(S^{-1} R S\)</span> 也是一个表示。如果我们有一个表示，那么就能利用任意可逆矩阵变出好多其他表示，新表示的形式可以更漂亮（比如让它是对角矩阵）。</p>
<h4 id="不变子空间">不变子空间</h4>
<p>给定群 <span class="math inline">\(G\)</span> 在向量空间 <span class="math inline">\(V\)</span> 上的表示 <span class="math inline">\(R,\)</span> 如果 <span class="math inline">\(V^{\prime} \subset V\)</span> 满足 <span class="math display">\[
\forall v \in V^{\prime}, g \in G, \text { 都有 } R(g) v \in V^{\prime}
\]</span> 则 <span class="math inline">\(V^{\prime}\)</span> 称为 <span class="math inline">\(V\)</span>的<strong>不变子空间</strong>。</p>
<p>任意群元作用于 <span class="math inline">\(V^{\prime}\)</span> 中的任意向量所得向量仍然在 <span class="math inline">\(V^{\prime}\)</span> 内，这就可以在 <span class="math inline">\(V^{\prime}\)</span> 上定义群 <span class="math inline">\(G\)</span> 的表示 <span class="math inline">\(R^{\prime}\)</span> 了: <span class="math display">\[
R^{\prime}(g) v=R(g) v, \quad \forall v \in V^{\prime}, g \in G
\]</span> 这种情况下，表示 <span class="math inline">\(R\)</span> 就有一种不够基本的感觉，它更像是多个小基本部件所构成的。我们称原来的表示 <span class="math inline">\(R\)</span> 不是原来的向量空间 V的基本表示，<span class="math inline">\(R^{\prime}\)</span> 称为<strong>子表示</strong>。</p>
<h4 id="不可约表示">不可约表示</h4>
<p>定义了上述概念之后就能引入超级重要的<strong>不可约表示</strong>。</p>
<blockquote>
<p>群 <span class="math inline">\(G\)</span>在向量空间 <span class="math inline">\(V\)</span> 上的不可约表示 <span class="math inline">\(R\)</span> 意味着除了 0 空间和 <span class="math inline">\(V\)</span> 自身之外再无不变子空间。不可约表示是<strong>基本的</strong>，它们<strong>不能再分解</strong>为子表示。利用所有的不可约表示可导出其他所有表示。</p>
</blockquote>
<p>还可以从<strong>另一个角度</strong>看不可约表示: 不可约表示不能通过<strong>相似变换</strong>变成分块对角矩阵形式。而可约表示能被相似变换变成分块对角形式。表示的可约性很关键，比如描述基本粒子要用不可约表示，基本粒子在变换下的行为由相应对称群的不可约表示描述。</p>
<h3 id="casimir-元">Casimir 元</h3>
<blockquote>
<p>一个群有许多表示，怎么知道哪个是描述自然的基本表示？</p>
</blockquote>
<p>Casimir 元可以给我们答案。Casimir 元（记作 <span class="math inline">\(C\)</span>）从 Lie 代数的元素 一生成元导出，它的定义是，对任意生成元 X 都有 <span class="math display">\[
[C, X]=0
\]</span> 著名的 Schur 引理告诉我们</p>
<blockquote>
<p>给定一个不可约群表示 <span class="math inline">\(R: g \rightarrow\)</span> <span class="math inline">\(G L(V),\)</span> 如果某个线性变换 <span class="math inline">\(T: V \rightarrow V(\)</span> 即 <span class="math inline">\(T \in G L(V))\)</span> 与所有<span class="math inline">\(R(g), \forall g \in G\)</span> 对易 ， 则 <span class="math inline">\(T\)</span> 必为恒等变换的常数倍。</p>
</blockquote>
<p>因此 Casimir元是群表示的<strong>“常数”</strong>，这些“常数”的值自然地为群表示“编号”。之后我们就从 Casimir 元对应编号最低的不可约表示开始。</p>
<p>群表示的定义与向量空间 V 有关。</p>
<blockquote>
<p><strong>一个表示就是将抽象群到 V 的线性变换的映射。</strong></p>
</blockquote>
<p>线性代数告诉我们以任意矩阵的本征向量为基可以张成一个向量空间。任意 Lie 群的生成元至少有一个可以通过相似变成对角矩阵，然后这个对角生成元的本征向量就可作为向量空间的基。</p>
<p>下一节导出 <span class="math inline">\(S U (2)\)</span> 群的不可约表示。研究 <span class="math inline">\(S U (2)\)</span> 是因为Lorentz 群的 Lie 代数是两份 <span class="math inline">\(S U (2)\)</span> 的 Lie 代数。Lorentz 群是Poincaré 群的一部分，本章由浅入深对他们逐一讨论。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/mathematics/">mathematics</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AF%B9%E7%A7%B0%E6%80%A7/">对称性</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BE%A4%E8%AE%BA/">群论</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2018/10/23/Cold_010_BEC/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">BEC玻色爱因斯坦凝聚</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2017/09/29/topology01_Introduction/">
                        <span class="hidden-mobile">Topology in Condensed matter Physics</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "基于对称性的物理(1/2)Lie群&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  
















</body>
</html>
